# Default values for helm-chart.
# This is a YAML-formatted file.
# Declare variables to be passed into your templates.
applicationName: creditmgmt-writeapi-v2-it04
environment: np
replicaCount: 1
namespace: cio-creditmgmt
# ingressClass: nginx-ingress-public-dv

# kubernetes.io/ingress.class: nginx-ingress-public-dv
kubernetes.io/ingress.class: nginx-ingress-protected
#type: deployment

# spec:
#   rules:
#   - host: usage-consumption-private-yul-np-001.cloudapps.telus.com
#     http:
#       paths:
#       - backend:
#           serviceName: usage-consumption-demo
#           servicePort: 80
#         path: /v1/api/usage-consumption/


#containerPort: 8090

#TELUS Labels/Annotations
telus:
  cmdbId: "16973"
  costCentre: "27105"
  organization: "CreditAndCollections"
  mailingList: "IS.Imagine.Collections@telus.com"

# Allows you set arbitrary env variables.
extraEnvs:
  - name: ENV
    value: STAGING-NP
  - name: SPRING_PROFILES_ACTIVE
    value: cloud-it04
  - name: GOOGLE_CLOUD_PROJECT
    value: cio-creditmgmt-np-15dfbe
#extraEnvs:
#  - name: envname
#    value: envvalue
#  - name: envname2
#    value: envvalue2

# Allows you to add any config files and specify a path location in the volumeMounts
# such as application.yaml or log4j2.properties.  Since this is clear in src control
# please do no use for sensitive data such as keys and passwords.  See Secrets.
#configmaps:
#  application.yaml: |
#    key:
#      nestedkey: value
#  log4j2.properties: |
#    key = value

# initContainers: |
#   - name: do-something
#     image: busybox
#     command: ['do', 'something']

# If you add a configmap you must add a volume names "configmap" to mount to a path of your choosing
# you can also mount arbitrary volumes or otherwise leave as an empty array
volumeMounts: []
#volumeMounts:
#  - name: configmap
#    path: /etc/config

#  - name: cache-dir
#    path: /etc/cache
#  - name: test-volume
#    path: /etc/gce-pd

livenessProbe:
  httpGet:
    path: /actuator/health/liveness
    port: 8080
  initialDelaySeconds: 120
  timeoutSeconds: 30
  periodSeconds: 30
  successThreshold: 1
  failureThreshold: 3

readinessProbe:
  httpGet:
    path: /actuator/health/readiness
    port: 8080
  initialDelaySeconds: 120
  timeoutSeconds: 30
  periodSeconds: 30
  successThreshold: 1
  failureThreshold: 3

    # livenessProbe:
    #   httpGet:
    #     path: /v1/api/
    #     port: 80

    # readinessProbe:
    #   httpGet:
    #     path: /v1/api/
    #     port: 80


    # Volume mounts should have an equivelent volume name defined of required type
    # this example creates and emptyDir type volume for ephemeral data
    # volumes: |
    #   - name: cache-dir
    #     emtptyDir: {}
    #   - name: test-volume
    # This GCE PD must already exist.
#     gcePersistentDisk:
#      pdName: my-data-disk
#      fsType: ext4

# Mount precreated secrets to a volume, it is determined the helm chart should not create secrets
# to protect security.  Please do not store secret data such as keys, keystores or passwords in Git
# or in a configmap
secretMounts: []
#secretMounts:
#  - name: keystores
#    secretName: app-keystores
#    path: /etc/secrets/keystores

image:
  repository: gcr.io/cio-gke-devops-e4993356/cio-creditmgmt/creditmgmt-writeapi-v2
  tag: latest
  pullPolicy: Always

#In order to get prometheus to scrape pods, you must add annotations to  the pods as below. 
# You should adjust prometheus.io/path based on the URL that your pod serves metrics from. prometheus.io/port should be set to the port that your pod serves metrics from. 
#Note that the values for prometheus.io/scrape and prometheus.io/port must be enclosed in double quotes.
prometheus:
  enable: true
  scrapePath: /actuator/prometheus
  scrapePort: 8080

#  metadata:
#    annotations:
#      prometheus.io/scrape: "true"
#      prometheus.io/path: /metrics
#      prometheus.io/port: "8080"



service:
  type: ClusterIP
  port: 8080


ingress:
  enabled: true
  # path: /v1/usage-consumption/api/
  path: /
  hosts:
    - "creditmgmt-writeapi-v2-it04-private-yul-np-001"
  tls: []
    #  - secretName: chart-example-tls
    #    hosts:
    #      - chart-example.local

    # enable on kong ingress and add plugins
    # insure the hostname used is cname to the kong ingress A record.
    # class: kong
    # kongPlugins: key-auth

    # create required kong plugins
    # plugins are reusable within namespace
    # kong:
    # enabled: true
    # plugins:
    # - name: key-auth
    # plugin: key-auth
    # config:
    # key_names: apikey
    #    - name: acl
    #      plugin: acl
    #      config:
    #        name: test
    # consumers:
    # - name: testconsumer
    # username: test
    # credentials:
    # - name: testcredential
    # consumer: testconsumer
    # type: key-auth
    # add any additional credential config as required by type.
    # key for key-auth is autogenerated and can be seen via kubectl get kongcredential...
    # config:
  #   key: value


autoscaling:
  enabled: true
  minReplicas: 2
  maxReplicas: 10
  targetCPUUtilizationPercentage: 55
  targetMemoryUtilizationPercentage: 70

resources:
  limits:
    cpu: 2
    memory: 3000Mi
  requests:
    cpu: 900m
    memory: 1000Mi

nodeSelector: {}

tolerations: []

affinity: {}

sidecar: |
  - name: cloudsql-proxy-creditmgmt
    image: gcr.io/cloudsql-docker/gce-proxy:1.16
    command: ["/cloud_sql_proxy", "-instances=cio-creditmgmt-np-15dfbe:northamerica-northeast1:cio-creditmgmt-db-np=tcp:5432"]
    securityContext:
      runAsUser: 2
      allowPrivilegeEscalation: false
    resources:
       limits:
         cpu: 2
         memory: 1536Mi
       requests:
         cpu: 800m
         memory: 1000Mi